function New-FunctionDelegate {
<#
.SYNOPSIS

Provides an executable wrapper for an X86 or X86_64 function.

Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None

.DESCRIPTION

New-FunctionDelegate returns a delegate as a wrapper for an assembly
language function. This, for example, enables a malware analyst to
rip out and execute complicated compression or crypto leaf functions
(functions that don't call other functions). This also allows you to
marshal native parameters and return types to managed types.

.PARAMETER Parameters

Specifies an array of managed function parameters. For example, if
the function accepts two DWORDs, you would provide the following
array: @([UInt32], [UInt32]). 0-10 arguments may be provided. Note:
If a native parameter is a pointer, some .NET types will
automatically be marshalled as pointer types. For example, when
passed to your native function, [String] and [Byte[]] are passed as
pointers. Debugging may be required to validate how any arbitrary
type may be marshalled as a native parameter.

.PARAMETER ReturnType

Specifies the managed return type of the functions. For example, if
the function returns a FARPROC (i.e. function pointer), ReturnType
would be [IntPtr]. If the function returned a USHORT, ReturnType
would be [UInt16].

.PARAMETER FunctionBytes

Specifies the assembly language bytes of the function you want to
execute. You must ensure that the calling convention of the function
matches that of the native function.

.PARAMETER FunctionAddress

Specifies the virtual address of an internal function for which you
would like to create a wrapper method. Do not use this for exported
functions as that would be total overkill when you could just
develop a P/Invoke signature for it. Just be mindul that this clearly
won't work for all functions as internal functions may require some
state to be set that would only be available through normal execution.
If you're using this parameter though, it's a safe bet that you
probably already know what you're doing. This parameter is currently
only supported on x86 due to the fact that I haven't implemented a 
generic X86_64 call wrapper.

.PARAMETER CallingConvention

Specifies the calling convention - StdCall, Cdecl, FastCall,
ThisCall. This only applies to X86. Currently, for X86_64,
only FastCall is supported.

.PARAMETER DebugBreak

Inserts an INT3 (0xCC) prior to the function byte so that a debugger
will break on your function.

.EXAMPLE

$AddStdcall =  [Byte[]] @(
0x55,           # push ebp
0x89,0xE5,      # mov ebp, esp
0x8B,0x45,0x08, # mov eax, [ebp+0x08]
0x03,0x45,0x0C, # add eax, [ebp+0x0C]
0x89,0xEC,      # mov esp, ebp
0x5D,           # pop ebp
0xC2,0x08,0x00) # retn 8

$AddStd = New-FunctionDelegate -ReturnType ([Int32]) -Parameters @([Int32], [Int32]) -FunctionBytes $AddStdcall -CallingConvention StdCall
$AddStd.Invoke(1,2)

.EXAMPLE

$AddCdeclBytes = [Byte[]] @(
0x55,           # push ebp
0x89,0xE5,      # mov ebp, esp
0x8B,0x45,0x08, # mov eax, [ebp+0x08]
0x03,0x45,0x0C, # add eax, [ebp+0x0C]
0x89,0xEC,      # mov esp, ebp
0x5D,           # pop ebp
0xC3)           # ret

$AddCdecl = New-FunctionDelegate -ReturnType ([Int32]) -Parameters @([Int32], [Int32]) -FunctionBytes $AddCdeclBytes -CallingConvention Cdecl
$AddCdecl.Invoke(1,2)

.EXAMPLE

$AddFastcall = [Byte[]] @(
0x89,0xC8,      # mov eax, ecx
0x01,0xD0,      # add eax, edx
0xC3)           # ret

$AddFast = New-FunctionDelegate -ReturnType ([Int32]) -Parameters @([Int32], [Int32]) -FunctionBytes $AddFastcall -CallingConvention FastCall
$AddFast.Invoke(1,2)

.EXAMPLE

$AddThiscall = [Byte[]] @(
0x55,           # push ebp
0x89,0xE5,      # mov ebp, esp
0x89,0xC8,      # mov eax, ecx
0x03,0x45,0x08, # add eax, [ebp+0x08]
0x89,0xEC,      # mov esp, ebp
0x5D,           # pop ebp
0xC2,0x04,0x00) # retn 4

$AddThis = New-FunctionDelegate -ReturnType ([Int32]) -Parameters @([Int32], [Int32]) -FunctionBytes $AddThiscall -CallingConvention Thiscall
$AddThis.Invoke(1,2)

.EXAMPLE

$X64AddBytes = [Byte[]] @(
0x48,0x89,0xC8, # mov rax, rcx
0x48,0x01,0xD0, # add rax, rdx
0xC3)           # ret

$X64Add = New-FunctionDelegate -ReturnType ([Int32]) -Parameters @([Int32], [Int32]) -FunctionBytes $X64AddBytes
$X64Add.Invoke(1,2)

.EXAMPLE

$InternalFunctionRVA = 0x00187802
$ModuleBaseAddr = [Uri].Assembly.GetType('Microsoft.Win32.SafeNativeMethods')::LoadLibrary('C:\Windows\System32\ReallyInteresting.dll')
$InternalFunctionVA = [IntPtr]::Add($ModuleBaseAddr, $InternalFunctionRVA)
$InternalFunctionWrapper = New-FunctionDelegate -Parameters @([UInt32]) -ReturnType ([IntPtr]) -FunctionAddress $InternalFunctionVA -CallingConvention ThisCall
$InternalFunctionWrapper.Invoke(3)

.OUTPUTS

System.Delegate
#>

    [OutputType([Delegate])]
    [CmdletBinding(DefaultParameterSetName = 'Bytes')]
    Param (
        [Parameter(Position = 0)]
        [ValidateCount(1, 10)]
        [Type[]]
        $Parameters = (New-Object Type[](0)),
            
        [Parameter(Position = 1)]
        [Type]
        $ReturnType = [Void],

        [Parameter(Position = 2, Mandatory = $True, ParameterSetName = 'Bytes')]
        [ValidateNotNullOrEmpty()]
        [Byte[]]
        $FunctionBytes,

        [Parameter(Position = 2, Mandatory = $True, ParameterSetName = 'Address')]
        [IntPtr]
        $FunctionAddress,

        [Parameter(Position = 3)]
        [Runtime.InteropServices.CallingConvention]
        $CallingConvention,

        [Switch]
        $DebugBreak
    )

    function local:Get-DelegateType {
        
        [OutputType([Type])]
        Param (
            [Parameter(Position = 0)]
            [Type[]]
            $Parameters = (New-Object Type[](0)),
            
            [Parameter(Position = 1)]
            [Type]
            $ReturnType = [Void]
        )

        $Domain = [AppDomain]::CurrentDomain
        $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
        $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
        $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
        $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
        $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
        $MethodBuilder.SetImplementationFlags('Runtime, Managed')
        
        Write-Output $TypeBuilder.CreateType()
    }

    # Define VirtualAlloc if it isn't already defined
    try { $Kernel32 = [FunctionDelegate.Kernel32] } catch [Management.Automation.RuntimeException] {
        $DynAssembly = New-Object System.Reflection.AssemblyName('FunctionDelegate_Win32_Assembly')
        $AssemblyBuilder = [AppDomain]::CurrentDomain.DefineDynamicAssembly($DynAssembly, [Reflection.Emit.AssemblyBuilderAccess]::Run)
        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('FunctionDelegate_Win32_Module', $False)

        $TypeBuilder = $ModuleBuilder.DefineType('FunctionDelegate.Kernel32', 'Public, Class')

        $PInvokeMethod = $TypeBuilder.DefineMethod(
                                'VirtualAlloc',
                                'Public, Static, HideBySig', 
                                [Reflection.CallingConventions]::Standard, 
                                [IntPtr],
                                [Type[]]@([IntPtr], [IntPtr], [UInt32], [UInt32]))

        $PreserveSigConstructor = [Runtime.InteropServices.PreserveSigAttribute].GetConstructor(@())
        $PreserveSigCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($PreserveSigConstructor, @())

        $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))
        $FieldArray = [Reflection.FieldInfo[]] @(
            [Runtime.InteropServices.DllImportAttribute].GetField('EntryPoint'),
            [Runtime.InteropServices.DllImportAttribute].GetField('SetLastError'),
            [Runtime.InteropServices.DllImportAttribute].GetField('CallingConvention')
        )

        $FieldValueArray = [Object[]] @(
            'VirtualAlloc',
            $True,
            [Runtime.InteropServices.CallingConvention]::Winapi
        )

        $DllImportCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($DllImportConstructor,
                                                                                        @('kernel32.dll'),
                                                                                        $FieldArray,
                                                                                        $FieldValueArray)

        $PInvokeMethod.SetCustomAttribute($DllImportCustomAttribute)
        $null = $PInvokeMethod.DefineParameter(1, 'None', 'lpAddress')
        $null = $PInvokeMethod.DefineParameter(2, 'None', 'dwSize')
        $null = $PInvokeMethod.DefineParameter(3, 'None', 'flAllocationType')
        $null = $PInvokeMethod.DefineParameter(4, 'None', 'flProtect')

        $Kernel32 = $TypeBuilder.CreateType()
    }

    if ($DebugBreak) { $Int3 = [Byte[]] @(0xCC) } else { $Int3 = [Byte[]] @(0x90) }

    if ([IntPtr]::Size -eq 4) {
        if (-not $CallingConvention) {
            throw 'You must specify a calling convention for 32-bit code.'
        }

        # Prologue bytes that will remain consistent despite the calling convention used
        $CommonPrologueBytes = [Byte[]] @(
            0x55,      # push ebp     ; Set up EBP-based frame
            0x89,0xE5, # mov ebp, esp
            0x57,      # push edi     ; Preserve all non-volatile registers
            0x56,      # push esi     ; We can't trust our callee to preserve non-volatile register
            0x53       # push ebx
        )

        # The arguments are the same for both stdcall and cdecl
        $StdcallArgs = @(
            [Byte[]] @(0xFF, 0x75, 0x08), # push dword [ebp+0x08]
            [Byte[]] @(0xFF, 0x75, 0x0C)  # push dword [ebp+0x0C]
        )

        # In fastcall, arg0 is passed via ECX, arg1 is passed via EDX
        $FastcallArgs = @(
            [Byte[]] @(0x8B, 0x4D, 0x08), # mov ecx,[ebp+0x8]
            [Byte[]] @(0x8B, 0x55, 0x0C)  # mov edx,[ebp+0xc]
        )

        # In thiscall, 'this' (or arg0) is passed via ECX
        $ThiscallArgs = @(
            [Byte[]] @(0x8B, 0x4D, 0x08), # mov ecx,[ebp+0x8]
            [Byte[]] @(0xFF, 0x75, 0x0C)  # push dword [ebp+0x0C]
        )

        # Argument pushes common to all calling conventions
        $CommonArgs = @(
            [Byte[]] @(0xFF, 0x75, 0x10), # push dword [ebp+0x10]
            [Byte[]] @(0xFF, 0x75, 0x14), # push dword [ebp+0x14]
            [Byte[]] @(0xFF, 0x75, 0x18), # push dword [ebp+0x18]
            [Byte[]] @(0xFF, 0x75, 0x1C), # push dword [ebp+0x1C]
            [Byte[]] @(0xFF, 0x75, 0x20), # push dword [ebp+0x20]
            [Byte[]] @(0xFF, 0x75, 0x24), # push dword [ebp+0x24]
            [Byte[]] @(0xFF, 0x75, 0x28), # push dword [ebp+0x28]
            [Byte[]] @(0xFF, 0x75, 0x2C)  # push dword [ebp+0x2C]
        )

        # Epilogue bytes that will remain consistent despite the calling convention used
        $CommonEpilogueBytes = [Byte[]] @(
            0x5B,      # pop ebx      ; Restore all non-volatile registers
            0x5E,      # pop esi
            0x5F,      # pop edi
            0x89,0xEC, # mov esp, ebp ; Restore frame of caller
            0x5D,      # pop ebp
            0xC3)      # ret


        # If the calling convention requires that we adjust the stack upon returning to the caller,
        # we will do so by this value.
        $Adjustment = [Byte[]] @([IntPtr]::Size * $Parameters.Length)

        $StackAdjustment = [Byte[]] @()

        # Choose the respective argument setup and stack adjustment
        # according to the calling convention specified
        switch ($CallingConvention) {
            'StdCall'  { $Arguments = $StdcallArgs }

            'Winapi' { $Arguments = $StdcallArgs }

            'FastCall' { $Arguments = $FastcallArgs }

            'Cdecl' {
                $Arguments = $StdcallArgs
                $StackAdjustment = [Byte[]] @(0x83, 0xC4) + $Adjustment # add esp, STACK_ADJUSTMENT
            }

            'ThisCall' { $Arguments = $ThiscallArgs }
        }

        # Append the push arguments that are common to all calling conventions
        $Arguments += $CommonArgs

        # THis will comprise the collection of push arguments
        $ArgumentBytes = [Byte[]] @()

        # Collect all of the relevant push arguments for the wrapper function
        for ($i = 0; $i -lt $Parameters.Length; $i++) { $ArgumentBytes += $Arguments[$i] }

        # Allocate RWX memory for the target function
        # Note: no, this function was not intended for stealth. Creation of arbitrary RWX and W->RX pages
        # is likely to get you caught - e.g. the Windows Defender Exploit Guard Arbitary Code Guard
        # mitigation (Microsoft-Windows-Security-Mitigations/KernelMode EID 1 and 2) is an example of something
        # that could detect/block this.
        if ($FunctionBytes) {
            $PBytes = $Kernel32::VirtualAlloc([IntPtr]::Zero, [IntPtr] $FunctionBytes.Length, 0x3000, 0x40)
            [Runtime.InteropServices.Marshal]::Copy($FunctionBytes, 0, $PBytes, $FunctionBytes.Length)
        } else {
            # -FunctionAddress was specified. They are mutually exclusive (via parametersets) and mandatory so I can get away with this logic.
            # It is assumed that the address you supplied point to actual, executable code.
            $PBytes = $FunctionAddress
        }

        $AddrBytes = [BitConverter]::GetBytes([Int32] $PBytes)

        # Note: this will need to change once I support passing of arguments via arbitrary registers (__usercall).
        $CallBytes = [Byte[]] @(
            0xB8 ) + $AddrBytes + [Byte[]] @( # mov eax, CALL_TARGET
            0xFF, 0xD0) +                     # call eax
            $StackAdjustment

        # Compose the entire calling convention converter wrapper function
        [Byte[]] $FunctionWrapperBytes = $Int3 +
            $CommonPrologueBytes +
            $ArgumentBytes +
            $CallBytes +
            $CommonEpilogueBytes

        # Allocate RWX memory for the wrapper function
        # Again, not intended for stealth.
        $PWrapper = $Kernel32::VirtualAlloc([IntPtr]::Zero, [IntPtr] $FunctionWrapperBytes.Length, 0x3000, 0x40)
        [Runtime.InteropServices.Marshal]::Copy($FunctionWrapperBytes, 0, $PWrapper, $FunctionWrapperBytes.Length)

        # Cast the wrapper function to a delegate so it can be invoked from within PowerShell
        $Prototype = Get-DelegateType $Parameters $ReturnType
        $Delegate = [Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($PWrapper, $Prototype)
    } else {
        if ($FunctionBytes) {
            if ($CallingConvention -eq 'FastCall') {
                # Only fastcall is currently supported for X86_64

                $X64Bytes = $Int3 + $FunctionBytes

                # Allocate RWX memory for the target function
                # Again, not intended for stealth.
                $PBytes = $Kernel32::VirtualAlloc([IntPtr]::Zero, [IntPtr] $X64Bytes.Length, 0x3000, 0x40)
                [Runtime.InteropServices.Marshal]::Copy($X64Bytes, 0, $PBytes, $X64Bytes.Length)

                # Cast the wrapper function to a delegate so it can be invoked from within PowerShell
                $Prototype = Get-DelegateType $Parameters $ReturnType
                $Delegate = [Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($PBytes, $Prototype)
            } else {
                Write-Error "The $CallingConvention calling convention is not supported on X86_64. Only FastCall is supported."
            }
        } else {
            Write-Error '-FunctionAddress is not currently supported on X86_64.'
            return
        }
    }

    return $Delegate
}